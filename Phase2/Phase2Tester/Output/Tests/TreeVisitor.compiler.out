const vmt_TV
	:TV.Start

const vmt_Tree
	:Tree.Init
	:Tree.SetRight
	:Tree.SetLeft
	:Tree.GetRight
	:Tree.GetLeft
	:Tree.GetKey
	:Tree.SetKey
	:Tree.GetHas_Right
	:Tree.GetHas_Left
	:Tree.SetHas_Left
	:Tree.SetHas_Right
	:Tree.Compare
	:Tree.Insert
	:Tree.Delete
	:Tree.Remove
	:Tree.RemoveRight
	:Tree.RemoveLeft
	:Tree.Search
	:Tree.Print
	:Tree.RecPrint
	:Tree.accept

const vmt_Visitor
	:Visitor.visit

const vmt_MyVisitor
	:MyVisitor.visit

func Main()
	t.0 = HeapAllocZ(4)
	[t.0] = :vmt_TV
	if t.0 goto :null1
		Error("null pointer")
	null1:
	t.1 = [t.0]
	t.1 = [t.1+0]
	t.2 = call t.1(t.0)
	PrintIntS(t.2)
	ret

func TV.Start(this )
	t.0 = Treeroot
	t.1 = Treerootntb
	t.2 = Treerootntbnti
	t.3 = TreerootntbntiMyVisitorv
	t.5 = [root]
	t.5 = [t.5+0]
	t.6 = call t.5(root 16)
	t.7 = [root]
	t.7 = [t.7+0]
	t.8 = call t.7(root)
	PrintIntS(t.8)
	t.9 = [root]
	t.9 = [t.9+0]
	t.10 = call t.9(root 8)
	t.11 = [root]
	t.11 = [t.11+0]
	t.12 = call t.11(root 24)
	t.13 = [root]
	t.13 = [t.13+0]
	t.14 = call t.13(root 4)
	t.15 = [root]
	t.15 = [t.15+0]
	t.16 = call t.15(root 12)
	t.17 = [root]
	t.17 = [t.17+0]
	t.18 = call t.17(root 20)
	t.19 = [root]
	t.19 = [t.19+0]
	t.20 = call t.19(root 28)
	t.21 = [root]
	t.21 = [t.21+0]
	t.22 = call t.21(root 14)
	t.23 = [root]
	t.23 = [t.23+0]
	t.24 = call t.23(root)
	PrintIntS(t.24)
	v = MyVisitor
	PrintIntS(t.24)
	t.25 = [root]
	t.25 = [t.25+0]
	t.26 = call t.25(root v)
	PrintIntS(t.26)
	t.27 = [root]
	t.27 = [t.27+0]
	t.28 = call t.27(root 24)
	PrintIntS(t.28)
	t.29 = [root]
	t.29 = [t.29+0]
	t.30 = call t.29(root 12)
	PrintIntS(t.30)
	t.31 = [root]
	t.31 = [t.31+0]
	t.32 = call t.31(root 16)
	PrintIntS(t.32)
	t.33 = [root]
	t.33 = [t.33+0]
	t.34 = call t.33(root 50)
	PrintIntS(t.34)
	t.35 = [root]
	t.35 = [t.35+0]
	t.36 = call t.35(root 12)
	PrintIntS(t.36)
	t.37 = [root]
	t.37 = [t.37+0]
	t.38 = call t.37(root 12)
	t.39 = [root]
	t.39 = [t.39+0]
	t.40 = call t.39(root)
	t.41 = [root]
	t.41 = [t.41+0]
	t.42 = call t.41(root 12)
	PrintIntS(t.42)
	ret 0
t.0 = TreeTreeleft
t.1 = TreeTreeleftTreeright
t.2 = TreeTreeleftTreerightkey
t.3 = TreeTreeleftTreerightkeyhas_left
t.4 = TreeTreeleftTreerightkeyhas_lefthas_right
t.5 = TreeTreeleftTreerightkeyhas_lefthas_rightTreemy_null
func Tree.Init(this v_key)
	has_left = 0
	has_right = 0
	ret 1
func Tree.SetRight(this Treern)
	right = rn
	ret 1
func Tree.SetLeft(this Treeln)
	left = ln
	ret 1
func Tree.GetRight(this )
	ret right
func Tree.GetLeft(this )
	ret left
func Tree.GetKey(this )
	ret key
func Tree.SetKey(this v_key)
	key = v_key
	ret 1
func Tree.GetHas_Right(this )
	ret has_right
func Tree.GetHas_Left(this )
	ret has_left
func Tree.SetHas_Left(this val)
	has_left = val
	ret 1
func Tree.SetHas_Right(this val)
	has_right = val
	ret 1
func Tree.Compare(this num1num2)
	t.0 = ntb
	t.1 = ntbnti
	ntb = 0
	nti = Add(num2 t.2)
	nti = Add(num21
	t.2 = LtS(num1 num2)
	if0 t.2 goto :if1_else
		ntb = 0
		ntb = 0
		goto :if1_end
	if1_else:
		t.2 = LtS(num1 nti)
		if1 t.2 goto :if2_else
			ntb = 0
			ntb = 0
			goto :if2_end
		if2_else:
			ntb = 1
		if2_end:
	if1_end:
	ret ntb
func Tree.Insert(this v_key)
	t.0 = Treenew_node
	t.1 = Treenew_nodentb
	t.2 = Treenew_nodentbTreecurrent_node
	t.3 = Treenew_nodentbTreecurrent_nodecont
	t.4 = Treenew_nodentbTreecurrent_nodecontkey_aux
	new_node = Tree
	t.6 = [new_node]
	t.6 = [t.6+0]
	t.7 = call t.6(new_node v_key)
	current_node = this
	cont = 1
	while2_top:
	t.7 = [this+8]
	if3t.8goto :while1_end
		t.9 = [current_node]
		t.9 = [t.9+0]
		t.10 = call t.9(current_node)
		t.10 = LtS(v_key key_aux)
		if3 t.10 goto :if4_else
			t.11 = [current_node]
			t.11 = [t.11+0]
			t.12 = call t.11(current_node)
			if4 t.12 goto :if5_else
				t.13 = [current_node]
				t.13 = [t.13+0]
				t.14 = call t.13(current_node)
				
				goto :if5_end
			if5_else:
				cont = 0
				t.15 = [current_node]
				t.15 = [t.15+0]
				t.16 = call t.15(current_node 1)
				t.17 = [current_node]
				t.17 = [t.17+0]
				t.18 = call t.17(current_node new_node)
			if5_end:
			new_node
			goto :if4_end
		if4_else:
			t.19 = [current_node]
			t.19 = [t.19+0]
			t.20 = call t.19(current_node)
			if5 t.20 goto :if6_else
				t.21 = [current_node]
				t.21 = [t.21+0]
				t.22 = call t.21(current_node)
				
				goto :if6_end
			if6_else:
				cont = 0
				t.23 = [current_node]
				t.23 = [t.23+0]
				t.24 = call t.23(current_node 1)
				t.25 = [current_node]
				t.25 = [t.25+0]
				t.26 = call t.25(current_node new_node)
			if6_end:
		if4_end:
	while1_end:
	ret 1
func Tree.Delete(this v_key)
	t.0 = Treecurrent_node
	t.1 = Treecurrent_nodeTreeparent_node
	t.2 = Treecurrent_nodeTreeparent_nodecont
	t.3 = Treecurrent_nodeTreeparent_nodecontfound
	t.4 = Treecurrent_nodeTreeparent_nodecontfoundntb
	t.5 = Treecurrent_nodeTreeparent_nodecontfoundntbis_root
	t.6 = Treecurrent_nodeTreeparent_nodecontfoundntbis_rootkey_aux
	current_node = this
	parent_node = this
	cont = 1
	found = 0
	is_root = 1
	while3_top:
	t.7 = [this+8]
	if7t.8goto :while2_end
		t.9 = [current_node]
		t.9 = [t.9+0]
		t.10 = call t.9(current_node)
		t.10 = LtS(v_key key_aux)
		if7 t.10 goto :if8_else
			t.11 = [current_node]
			t.11 = [t.11+0]
			t.12 = call t.11(current_node)
			if8 t.12 goto :if9_else
				t.13 = [current_node]
				t.13 = [t.13+0]
				t.14 = call t.13(current_node)
				
				goto :if9_end
			if9_else:
				cont = 0
			if9_end:
			cont = 0
			goto :if8_end
		if8_else:
			t.14 = LtS(key_aux v_key)
			if9 t.14 goto :if10_else
				t.15 = [current_node]
				t.15 = [t.15+0]
				t.16 = call t.15(current_node)
				if10 t.16 goto :if11_else
					t.17 = [current_node]
					t.17 = [t.17+0]
					t.18 = call t.17(current_node)
					
					goto :if11_end
				if11_else:
					cont = 0
				if11_end:
				cont = 0
				goto :if10_end
			if10_else:
				if11 t.18 goto :if12_else
					t.19 = [current_node]
					t.19 = [t.19+0]
					t.20 = call t.19(current_node)
					t.21 = [current_node]
					t.21 = [t.21+0]
					t.22 = call t.21(current_node)
					if12 t.22 goto :if13_else
						ntb = 1
						goto :if13_end
					if13_else:
						t.23 = [this]
						t.23 = [t.23+0]
						t.24 = call t.23(this parent_nodecurrent_node)
					if13_end:
					parent_nodecurrent_node
					goto :if12_end
				if12_else:
					t.25 = [this]
					t.25 = [t.25+0]
					t.26 = call t.25(this parent_nodecurrent_node)
				if12_end:
				found = 1
				cont = 0
			if10_end:
		if8_end:
		is_root = 0
	while2_end:
	ret found
func Tree.Remove(this Treep_nodeTreec_node)
	t.0 = ntb
	t.1 = ntbauxkey1
	t.2 = ntbauxkey1auxkey2
	t.4 = [c_node]
	t.4 = [t.4+0]
	t.5 = call t.4(c_node)
	if13 t.5 goto :if14_else
		t.6 = [this]
		t.6 = [t.6+0]
		t.7 = call t.6(this p_nodec_node)
		p_nodec_node
		goto :if14_end
	if14_else:
		t.8 = [c_node]
		t.8 = [t.8+0]
		t.9 = call t.8(c_node)
		if14 t.9 goto :if15_else
			t.10 = [this]
			t.10 = [t.10+0]
			t.11 = call t.10(this p_nodec_node)
			p_nodec_node
			goto :if15_end
		if15_else:
			t.12 = [c_node]
			t.12 = [t.12+0]
			t.13 = call t.12(c_node)
			t.14 = [p_node]
			t.14 = [t.14+0]
			t.15 = call t.14(p_node)
			t.16 = []
			t.16 = [t.16+0]
			t.17 = call t.16()
			t.18 = [this]
			t.18 = [t.18+0]
			t.19 = call t.18(this auxkey1auxkey2)
			if15 t.19 goto :if16_else
				t.20 = [p_node]
				t.20 = [t.20+0]
				t.21 = call t.20(p_node my_null)
				t.22 = [p_node]
				t.22 = [t.22+0]
				t.23 = call t.22(p_node 0)
				0
				goto :if16_end
			if16_else:
				t.24 = [p_node]
				t.24 = [t.24+0]
				t.25 = call t.24(p_node my_null)
				t.26 = [p_node]
				t.26 = [t.26+0]
				t.27 = call t.26(p_node 0)
			if16_end:
		if15_end:
	if14_end:
	ret 1
func Tree.RemoveRight(this Treep_nodeTreec_node)
	t.0 = ntb
	t.2 = [c_node]
	t.2 = [t.2+0]
	t.3 = call t.2(c_node)
	while4_top:
	t.3 = [this+8]
	if17t.4goto :while3_end
		t.5 = [c_node]
		t.5 = [t.5+0]
		t.7 = [c_node]
		t.7 = [t.7+0]
		t.8 = call t.7(c_node)
		t.9 = []
		t.9 = [t.9+0]
		t.10 = call t.9()
		t.10 = call t.9(c_node)
		p_node = c_node
		t.11 = [c_node]
		t.11 = [t.11+0]
		t.12 = call t.11(c_node)
	while3_end:
	t.13 = [p_node]
	t.13 = [t.13+0]
	t.14 = call t.13(p_node my_null)
	t.15 = [p_node]
	t.15 = [t.15+0]
	t.16 = call t.15(p_node 0)
	ret 1
func Tree.RemoveLeft(this Treep_nodeTreec_node)
	t.0 = ntb
	t.2 = [c_node]
	t.2 = [t.2+0]
	t.3 = call t.2(c_node)
	while5_top:
	t.3 = [this+8]
	if18t.4goto :while4_end
		t.5 = [c_node]
		t.5 = [t.5+0]
		t.7 = [c_node]
		t.7 = [t.7+0]
		t.8 = call t.7(c_node)
		t.9 = []
		t.9 = [t.9+0]
		t.10 = call t.9()
		t.10 = call t.9(c_node)
		p_node = c_node
		t.11 = [c_node]
		t.11 = [t.11+0]
		t.12 = call t.11(c_node)
	while4_end:
	t.13 = [p_node]
	t.13 = [t.13+0]
	t.14 = call t.13(p_node my_null)
	t.15 = [p_node]
	t.15 = [t.15+0]
	t.16 = call t.15(p_node 0)
	ret 1
func Tree.Search(this v_key)
	t.0 = Treecurrent_node
	t.1 = Treecurrent_nodeifound
	t.2 = Treecurrent_nodeifoundcont
	t.3 = Treecurrent_nodeifoundcontkey_aux
	current_node = this
	cont = 1
	ifound = 0
	while6_top:
	t.4 = [this+8]
	if19t.5goto :while5_end
		t.6 = [current_node]
		t.6 = [t.6+0]
		t.7 = call t.6(current_node)
		t.7 = LtS(v_key key_aux)
		if19 t.7 goto :if20_else
			t.8 = [current_node]
			t.8 = [t.8+0]
			t.9 = call t.8(current_node)
			if20 t.9 goto :if21_else
				t.10 = [current_node]
				t.10 = [t.10+0]
				t.11 = call t.10(current_node)
				
				goto :if21_end
			if21_else:
				cont = 0
			if21_end:
			cont = 0
			goto :if20_end
		if20_else:
			t.11 = LtS(key_aux v_key)
			if21 t.11 goto :if22_else
				t.12 = [current_node]
				t.12 = [t.12+0]
				t.13 = call t.12(current_node)
				if22 t.13 goto :if23_else
					t.14 = [current_node]
					t.14 = [t.14+0]
					t.15 = call t.14(current_node)
					
					goto :if23_end
				if23_else:
					cont = 0
				if23_end:
				cont = 0
				goto :if22_end
			if22_else:
				ifound = 1
				cont = 0
			if22_end:
		if20_end:
	while5_end:
	ret ifound
func Tree.Print(this )
	t.0 = ntb
	t.1 = ntbTreecurrent_node
	current_node = this
	t.3 = [this]
	t.3 = [t.3+0]
	t.4 = call t.3(this current_node)
	ret 1
func Tree.RecPrint(this Treenode)
	t.0 = ntb
	t.2 = [node]
	t.2 = [t.2+0]
	t.3 = call t.2(node)
	if23 t.3 goto :if24_else
		t.4 = [this]
		t.4 = [t.4+0]
		t.6 = [node]
		t.6 = [t.6+0]
		t.7 = call t.6(node)
		t.7 = call t.6(this)
		
		goto :if24_end
	if24_else:
		ntb = 1
	if24_end:
	t.8 = [node]
	t.8 = [t.8+0]
	t.9 = call t.8(node)
	PrintIntS(t.9)
	t.10 = [node]
	t.10 = [t.10+0]
	t.11 = call t.10(node)
	if24 t.11 goto :if25_else
		t.12 = [this]
		t.12 = [t.12+0]
		t.14 = [node]
		t.14 = [t.14+0]
		t.15 = call t.14(node)
		t.15 = call t.14(this)
		
		goto :if25_end
	if25_else:
		ntb = 1
	if25_end:
	ret 1
func Tree.accept(this Visitorv)
	t.0 = nti
	PrintIntS(t.1)
	t.2 = [v]
	t.2 = [t.2+0]
	t.3 = call t.2(v this)
	ret 0
t.0 = VisitorTreel
t.1 = VisitorTreelTreer
func Visitor.visit(this Treen)
	t.2 = nti
	t.4 = [n]
	t.4 = [t.4+0]
	t.5 = call t.4(n)
	if25 t.5 goto :if26_else
		t.6 = [n]
		t.6 = [t.6+0]
		t.7 = call t.6(n)
		t.8 = [r]
		t.8 = [t.8+0]
		t.9 = call t.8(r this)
		this
		goto :if26_end
	if26_else:
		nti = 0
	if26_end:
	t.10 = [n]
	t.10 = [t.10+0]
	t.11 = call t.10(n)
	if26 t.11 goto :if27_else
		t.12 = [n]
		t.12 = [t.12+0]
		t.13 = call t.12(n)
		t.14 = [l]
		t.14 = [t.14+0]
		t.15 = call t.14(l this)
		this
		goto :if27_end
	if27_else:
		nti = 0
	if27_end:
	ret 0
func Visitor.visit(this Treen)
	t.0 = nti
	t.2 = [n]
	t.2 = [t.2+0]
	t.3 = call t.2(n)
	if27 t.3 goto :if28_else
		t.4 = [n]
		t.4 = [t.4+0]
		t.5 = call t.4(n)
		t.6 = [r]
		t.6 = [t.6+0]
		t.7 = call t.6(r this)
		this
		goto :if28_end
	if28_else:
		nti = 0
	if28_end:
	t.8 = [n]
	t.8 = [t.8+0]
	t.9 = call t.8(n)
	PrintIntS(t.9)
	t.10 = [n]
	t.10 = [t.10+0]
	t.11 = call t.10(n)
	if28 t.11 goto :if29_else
		t.12 = [n]
		t.12 = [t.12+0]
		t.13 = call t.12(n)
		t.14 = [l]
		t.14 = [t.14+0]
		t.15 = call t.14(l this)
		this
		goto :if29_end
	if29_else:
		nti = 0
	if29_end:
	ret 0
